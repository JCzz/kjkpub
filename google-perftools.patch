Index: src/tcmalloc.cc
===================================================================
--- src/tcmalloc.cc	(revision 45)
+++ src/tcmalloc.cc	(working copy)
@@ -94,6 +94,10 @@
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
+#ifdef HAVE_EXECINFO_H
+#include <execinfo.h>
+#endif
+
 #include <errno.h>
 #include <stdarg.h>
 #include "packed-cache-inl.h"
@@ -249,6 +253,11 @@
               "to return memory slower.  Reasonable rates are in the "
               "range [0,10]");
 
+DEFINE_uint64(tcmalloc_alloc_limit, 0,
+              "Limits the total alloc size. Will fail malloc/new if "
+              "allocation would cause to allocate more memory than"
+              "the limit");
+    
 //-------------------------------------------------------------------
 // Mapping from size to size_class and vice versa
 //-------------------------------------------------------------------
@@ -2327,6 +2336,21 @@
   }
 }
 
+// Returned a number of bytes currently allocated by the app
+// TODO: it's slow. I was thinking about keeping a running count and updating
+// it in do_malloc() and do_free(), but couldn't figure out how to get the
+// size of allocation from the pointer in do_free()
+static uint64_t GetAllocatedBytes() {
+  TCMallocStats stats;
+  ExtractStats(&stats, NULL);
+  const uint64_t bytes_in_use = stats.system_bytes
+                                - stats.pageheap_bytes
+                                - stats.central_bytes
+                                - stats.transfer_bytes
+                                - stats.thread_bytes;
+  return bytes_in_use;
+}
+
 // WRITE stats to "out"
 static void DumpStats(TCMalloc_Printer* out, int level) {
   TCMallocStats stats;
@@ -2600,6 +2624,14 @@
     TCMalloc_ThreadCache::InitTSD();
     free(malloc(1));
     MallocExtension::Register(new TCMallocImplementation);
+    const char* env = getenv("MALLOCLIMIT");
+    if (env != NULL) {
+      int limit = atoi(env);
+      if (limit > 0) {
+        FLAGS_tcmalloc_alloc_limit = limit;
+        printf("Setting malloc limit to %d\n", limit);
+      }
+    }
   }
 
   ~TCMallocGuard() {
@@ -2678,12 +2710,33 @@
   return span == NULL ? NULL : SpanToMallocResult(span);
 }
 
+static const int kMaxStackTrace = 32;
+
 static inline void* do_malloc(size_t size) {
   void* ret = NULL;
-
   // The following call forces module initialization
   TCMalloc_ThreadCache* heap = TCMalloc_ThreadCache::GetCache();
-  if ((FLAGS_tcmalloc_sample_parameter > 0) && heap->SampleAllocation(size)) {
+  if ((FLAGS_tcmalloc_alloc_limit > 0) && (GetAllocatedBytes() + size) > FLAGS_tcmalloc_alloc_limit) {
+    // TODO: use sth. better than printf
+    printf("\nFailing allocation of size %d because reached allocation limit. Callstack:\n", (int)size);
+    void* key[kMaxStackTrace];
+    int depth = MallocHook::GetCallerStackTrace(key, kMaxStackTrace, 1);
+    uint64 prevLimit = FLAGS_tcmalloc_alloc_limit;
+    FLAGS_tcmalloc_alloc_limit = 0;
+#ifdef HAVE_EXECINFO_H
+    char ** syms = backtrace_symbols(key, depth);
+    for (int i = 0; key && (i < depth); i++) {
+      printf("%p, %s\n", key[i], syms[i]);
+    }
+    free(syms);
+#else
+    for (int i = 0; key && (i < depth); i++) {
+      printf("%p\n", key[i]);
+    }
+#endif
+    FLAGS_tcmalloc_alloc_limit = prevLimit;
+
+  } else if ((FLAGS_tcmalloc_sample_parameter > 0) && heap->SampleAllocation(size)) {
     Span* span = DoSampledAllocation(size);
     if (span != NULL) {
       ret = SpanToMallocResult(span);
